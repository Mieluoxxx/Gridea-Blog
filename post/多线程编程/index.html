<html lang="zh">
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>多线程编程 | 咕噜咕噜魔法使</title>

<link rel="shortcut icon" href="https://lab.moguw.top/favicon.ico?v=1711027564217">

<link href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://lab.moguw.top/styles/main.css">
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    
<link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/styles/base16/solarized-light.min.css">

<script src="https://fastly.jsdelivr.net/combine/gh/highlightjs/cdn-release@11.3.1/build/highlight.min.js,gh/highlightjs/cdn-release@11.3.1/build/languages/cpp.min.js,gh/highlightjs/cdn-release@11.3.1/build/languages/csharp.min.js,gh/highlightjs/cdn-release@11.3.1/build/languages/c.min.js,gh/highlightjs/cdn-release@11.3.1/build/languages/python.min.js,gh/highlightjs/cdn-release@11.3.1/build/languages/rust.min.js,gh/highlightjs/cdn-release@11.3.1/build/languages/xml.min.js,gh/highlightjs/cdn-release@11.3.1/build/languages/javascript.min.js,gh/highlightjs/cdn-release@11.3.1/build/languages/powershell.min.js,gh/highlightjs/cdn-release@11.3.1/build/languages/shell.min.js,gh/highlightjs/cdn-release@11.3.1/build/languages/sql.min.js,gh/highlightjs/cdn-release@11.3.1/build/languages/http.min.js,gh/highlightjs/cdn-release@11.3.1/build/languages/go.min.js,gh/highlightjs/cdn-release@11.3.1/build/languages/css.min.js"></script>

<!-- <script src="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/highlight.min.js"></script>
<script src="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/languages/cpp.min.js"></script>
<script src="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/languages/csharp.min.js"></script>
<script src="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/languages/c.min.js"></script>
<script src="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/languages/python.min.js"></script>
<script src="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/languages/rust.min.js"></script>
<script src="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/languages/xml.min.js"></script>
<script src="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/languages/javascript.min.js"></script>
<script src="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/languages/powershell.min.js"></script>
<script src="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/languages/shell.min.js"></script>
<script src="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/languages/sql.min.js"></script>
<script src="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/languages/http.min.js"></script>
<script src="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/languages/go.min.js"></script>
<script src="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/languages/css.min.js"></script>
 -->

    <link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/viewerjs@1.10.2/dist/viewer.min.css" />
<script src="https://fastly.jsdelivr.net/npm/viewerjs@1.10.2/dist/viewer.min.js"></script>

    <link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            咕噜咕噜魔法使
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="https://lab.moguw.top/tag/nl6HTtVUL/" class="menu gt-a-link">
                    考研408
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1711027564217"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function () {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    多线程编程
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2023-11-18 ·
                    </time>
                    
                        <a href="https://lab.moguw.top/tag/FC1o_1-MuX/" class="post-tags">
                            # 多线程
                        </a>
                    
                </div>
                <div class="post-content">
                    <p>文章参考: <a href="https://subingwen.cn/linux/thread/">爱编程的大丙</a></p>
<h2 id="1-线程概述">1. 线程概述</h2>
<p>线程是轻量级的进程（LWP：light weight process），在Linux环境下线程的本质仍是进程。在计算机上运行的程序是一组指令及指令参数的组合，指令按照既定的逻辑控制计算机运行。操作系统会以进程为单位，分配系统资源，可以这样理解，进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。<br>
先从概念上了解一下线程和进程之间的区别：</p>
<ul>
<li>
<p>进程有自己独立的地址空间, 多个线程共用同一个地址空间</p>
<ul>
<li>线程更加节省系统资源, 效率不仅可以保持的, 而且能够更高</li>
<li>在一个地址空间中多个线程独享: 每个线程都有属于自己的栈区, 寄存器(内核中管理的)</li>
<li>在一个地址空间中多个线程共享: 代码段, 堆区, 全局数据区, 打开的文件(文件描述符表)都是线程共享的</li>
</ul>
</li>
<li>
<p>线程是程序的最小执行单位, 进程是操作系统中最小的资源分配单位</p>
<ul>
<li>每个进程对应一个虚拟地址空间，一个进程只能抢一个CPU时间片</li>
<li>一个地址空间中可以划分出多个线程, 在有效的资源基础上, 能够抢更多的CPU时间片<br>
<img src="https://s2.loli.net/2023/11/18/oTGM5F9Zk2b86zI.png" alt="image.png" loading="lazy"></li>
</ul>
</li>
<li>
<p>CPU的调度和切换: 线程的上下文切换比进程要快的多</p>
</li>
<li>
<p>上下文切换：进程/线程分时复用CPU时间片，在切换之前会将上一个任务的状态进行保存, 下次切换回这个任务的时候, 加载这个状态继续运行，任务从保存到再次加载这个过程就是一次上下文切换。</p>
</li>
<li>
<p>线程更加廉价, 启动速度更快, 退出也快, 对系统资源的冲击小。</p>
</li>
<li>
<p>在处理多任务程序的时候使用多线程比使用多进程要更有优势，但是线程并不是越多越好，如何控制线程的个数呢？</p>
<ul>
<li>文件IO操作：文件IO对CPU是使用率不高, 因此可以分时复用CPU时间片, 线程的个数 = 2 * CPU核心数 (效率最高)</li>
<li>处理复杂的算法(主要是CPU进行运算, 压力大)，线程的个数 = CPU的核心数 (效率最高)</li>
</ul>
</li>
</ul>
<h2 id="2-创建线程">2. 创建线程</h2>
<p>每一个线程都有一个唯一的线程ID，ID类型为<code>pthread_t</code>，这个ID是一个无符号长整形数，如果想要得到当前线程的线程ID，可以调用如下函数：</p>
<pre><code class="language-c">pthread_t pthread_self(void);	// 返回当前线程的线程ID
</code></pre>
<p>在一个进程中调用线程创建函数，就可得到一个子线程，和进程不同，需要给每一个创建出的线程指定一个处理函数，否则这个线程无法工作。</p>
<pre><code class="language-c">#include &lt;pthread.h&gt;
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine) (void *), void *arg);
// Compile and link with -pthread, 线程库的名字叫pthread, 全名: libpthread.so libptread.a
</code></pre>
<p>参数:</p>
<ul>
<li><code>thread</code>: 传出参数，是无符号长整形数，线程创建成功, 会将线程ID写入到这个指针指向的内存中</li>
<li><code>attr</code>: 线程的属性, 一般情况下使用默认属性即可, 写 <code>NULL</code></li>
<li><code>start_routine</code>: 函数指针，创建出的子线程的处理动作，也就是该函数在子线程中执行。</li>
<li><code>arg</code>: 作为实参传递到 <code>start_routine</code> 指针指向的函数内部<br>
返回值：线程创建成功返回0，创建失败返回对应的错误号</li>
</ul>
<pre><code class="language-c">// pthread_create.c 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;

// 子线程的处理代码
void* working(void* arg) {
    printf(&quot;我是子线程, 线程ID: %ld\n&quot;, pthread_self());
    for(int i=0; i&lt;9; ++i) {
        printf(&quot;child == i: = %d\n&quot;, i);
    }
    return NULL;
}

int main() {
    // 1. 创建一个子线程
    pthread_t tid;
    pthread_create(&amp;tid, NULL, working, NULL);
    printf(&quot;子线程创建成功, 线程ID: %ld\n&quot;, tid);
    // 2. 子线程不会执行下边的代码, 主线程执行
    printf(&quot;我是主线程, 线程ID: %ld\n&quot;, pthread_self());
    for(int i=0; i&lt;3; ++i) {
        printf(&quot;i = %d\n&quot;, i);
    }
    // 休息, 休息一会儿...
    // sleep(1);
    return 0;
}
</code></pre>
<pre><code class="language-bash">$ gcc pthread_create.c -lpthread -o app
$ ./app
</code></pre>
<p>主线程一直在运行, 执行期间创建出了子线程，说明主线程有CPU时间片, 在这个时间片内将代码执行完毕了, 主线程就退出了。子线程被创建出来之后需要抢cpu时间片, 抢不到就不能运行，如果主线程退出了, 虚拟地址空间就被释放了, 子线程就一并被销毁了。但是如果某一个子线程退出了, 主线程仍在运行, 虚拟地址空间依旧存在。</p>
<p>得到的结论：<mark>在没有人为干预的情况下，虚拟地址空间的生命周期和主线程是一样的，与子线程无关。</mark></p>
<h2 id="3-线程退出">3. 线程退出</h2>
<p>在编写多线程程序的时候，如果想要让线程退出，但是不会导致虚拟地址空间的释放（针对于主线程），我们就可以调用线程库中的线程退出函数，<code>只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，不管是在子线程或者主线程中都可以使用</code>。</p>
<pre><code class="language-c">#include &lt;pthread.h&gt;
void pthread_exit(void *retval);
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;

// 子线程的处理代码
void* working(void* arg) {
    sleep(1);
    printf(&quot;我是子线程, 线程ID: %ld\n&quot;, pthread_self());
    for(int i=0; i&lt;9; ++i) {
        if(i==6) {
            pthread_exit(NULL);	// 直接退出子线程
        } 
        printf(&quot;child == i: = %d\n&quot;, i);
    }
    return NULL;
}

int main() {
    // 1. 创建一个子线程
    pthread_t tid;
    pthread_create(&amp;tid, NULL, working, NULL);

    printf(&quot;子线程创建成功, 线程ID: %ld\n&quot;, tid);
    // 2. 子线程不会执行下边的代码, 主线程执行
    printf(&quot;我是主线程, 线程ID: %ld\n&quot;, pthread_self());
    for(int i=0; i&lt;3; ++i) {
        printf(&quot;i = %d\n&quot;, i);
    }

    // 主线程调用退出函数退出, 地址空间不会被释放
    pthread_exit(NULL);
    
    return 0;
}
</code></pre>
<h2 id="4-线程回收">4. 线程回收</h2>
<p>线程和进程一样，子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函叫做<code>pthread_join()</code>，这个函数是一个阻塞函数，如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。</p>
<p>另外通过线程回收函数还可以获取到子线程退出时传递出来的数据，函数原型如下：</p>
<pre><code class="language-c">#include &lt;pthread.h&gt;
// 这是一个阻塞函数, 子线程在运行这个函数就阻塞
// 子线程退出, 函数解除阻塞, 回收对应的子线程资源, 类似于回收进程使用的函数 wait()
int pthread_join(pthread_t thread, void **retval);
</code></pre>
<p>参数:</p>
<ul>
<li><code>thread</code>: 要被回收的子线程的线程<code>ID</code></li>
<li><code>retval</code>: 二级指针, 指向一级指针的地址, 是一个传出参数, 这个地址中存储了<code>pthread_exit()</code> 传递出的数据，如果不需要这个参数，可以指定为<code>NULL</code><br>
返回值：线程回收成功返回<code>0</code>，回收失败返回错误号。</li>
</ul>
<h2 id="数数字问题">数数字问题</h2>
<h3 id="为什么要同步">为什么要同步</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;

#define MAX 50
// 全局变量
int number;

// 线程处理函数
void* funcA_num(void* arg) {
    for(int i=0; i&lt;MAX; ++i) {
        int cur = number;
        cur++;
        usleep(10);
        number = cur;
        printf(&quot;Thread A, id = %lu, number = %d\n&quot;, pthread_self(), number);
    }

    return NULL;
}

void* funcB_num(void* arg) {
    for(int i=0; i&lt;MAX; ++i) {
        int cur = number;
        cur++;
        number = cur;
        printf(&quot;Thread B, id = %lu, number = %d\n&quot;, pthread_self(), number);
        usleep(5);
    }

    return NULL;
}

int main(int argc, const char* argv[]) {
    pthread_t p1, p2;

    // 创建两个子线程
    pthread_create(&amp;p1, NULL, funcA_num, NULL);
    pthread_create(&amp;p2, NULL, funcB_num, NULL);

    // 阻塞，资源回收
    pthread_join(p1, NULL);
    pthread_join(p2, NULL);

    return 0;
}
</code></pre>
<h3 id="互斥锁的使用">互斥锁的使用</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;

#define MAX 100
// 全局变量
int number;

// 创建一把互斥锁
// 全局变量, 多个线程共享
pthread_mutex_t mutex;

// 线程处理函数
void* funcA_num(void* arg) {
    for(int i=0; i&lt;MAX; ++i) {
        // 如果线程A加锁成功, 不阻塞
        // 如果B加锁成功, 线程A阻塞
        pthread_mutex_lock(&amp;mutex);
        int cur = number;
        cur++;
        usleep(10);
        number = cur;
        pthread_mutex_unlock(&amp;mutex);
        printf(&quot;Thread A, id = %lu, number = %d\n&quot;, pthread_self(), number);
    }

    return NULL;
}

void* funcB_num(void* arg) {
    for(int i=0; i&lt;MAX; ++i) {
        // a加锁成功, b线程访问这把锁的时候是锁定的
        // 线程B先阻塞, a线程解锁之后阻塞解除
        // 线程B加锁成功了
        pthread_mutex_lock(&amp;mutex);
        int cur = number;
        cur++;
        number = cur;
        pthread_mutex_unlock(&amp;mutex);
        printf(&quot;Thread B, id = %lu, number = %d\n&quot;, pthread_self(), number);
        usleep(5);
    }

    return NULL;
}

int main(int argc, const char* argv[]) {
    pthread_t p1, p2;

    // 初始化互斥锁
    pthread_mutex_init(&amp;mutex, NULL);

    // 创建两个子线程
    pthread_create(&amp;p1, NULL, funcA_num, NULL);
    pthread_create(&amp;p2, NULL, funcB_num, NULL);

    // 阻塞，资源回收
    pthread_join(p1, NULL);
    pthread_join(p2, NULL);

    // 销毁互斥锁
    // 线程销毁之后, 再去释放互斥锁
    pthread_mutex_destroy(&amp;mutex);

    return 0;
}
</code></pre>
<h3 id="读写锁">读写锁</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;

#define MAX 50

// 全局变量
int number;
// 创建一把互斥锁
// 全局变量, 多个线程共享
pthread_rwlock_t rwlock;

// 线程处理函数

void* read_num(void* arg) {
	for(int i=0; i&lt;MAX; ++i) {
	// 如果线程A加锁成功, 不阻塞
	// 如果B加锁成功, 线程A阻塞
	pthread_rwlock_rdlock(&amp;rwlock);
	printf(&quot;Thread read, id = %lu, number = %d\n&quot;, pthread_self(), number);
	pthread_rwlock_unlock(&amp;rwlock);
	usleep(rand()%5);
}
	return NULL;
}

void* write_num(void* arg) {
	for(int i=0; i&lt;MAX; ++i) {
		pthread_rwlock_wrlock(&amp;rwlock);
		int cur = number;
		cur++;
		number = cur;
		pthread_rwlock_unlock(&amp;rwlock);
		printf(&quot;Thread write, id = %lu, number = %d\n&quot;, pthread_self(), number);
		usleep(5);
	}

	return NULL;
}

int main(int argc, const char* argv[]) {
	pthread_t p1[5], p2[3];
	// 初始化互斥锁
	pthread_rwlock_init(&amp;rwlock, NULL);
	// 创建两个子线程
	for (int i = 0; i &lt; 5; i++){
		pthread_create(&amp;p1[i], NULL, read_num, NULL);
	}
	for (int i = 0; i &lt; 3; i++) {
		pthread_create(&amp;p2[i], NULL, write_num, NULL);
	}
	// 阻塞，资源回收
	for (int i = 0; i &lt; 5; i++){
		pthread_join(p1[i], NULL);
	}
	for (int i = 0; i &lt; 3; i++) {
		pthread_join(p2[i], NULL);
	}
	// 销毁互斥锁
	// 线程销毁之后, 再去释放互斥锁
	pthread_rwlock_destroy(&amp;rwlock);
	return 0;
}
</code></pre>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://lab.moguw.top/post/SVM支持向量机/" class="post-title gt-a-link">
                    SVM支持向量机
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">真真夜夜的小木屋</div>
    <div class="social-container">
        
            
                <a href="https://github.com/Mieluoxxx" target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://lab.moguw.top/atom.xml" target="_blank">RSS</a>
    </div>
</div>

        <script>
  hljs.highlightAll();
</script>

        <script>
(function() {
	function addEventListener(element, type, handler) {
        if (element.addEventListener) {
            element.addEventListener(type, handler, false);
        } else if (element.attachEvent) {
            element.attachEvent('on' + type, handler);
        }
    }

    addEventListener(window, 'load', function () {
        var Viewer = window.Viewer;
        var pictures = document.querySelector('.post-content');
        var viewer = new Viewer(pictures);
    });
})();
</script>


        <script>
            var ele = document.querySelector(".waline-visitor-count");
            Object.defineProperty(ele, 'innerText', {
                get: function() {
                    return ele.innerText;
                },
                set: function(value) {
                    ele.innerHTML = value;
                    if (value > 0) {
	                    var parent = document.querySelector(".leancloud_visitors");
	                    parent.style.visibility="visible";
	                }
                }
            });
        </script>
    </div>
</div>
</body>
</html>
